package comp9313.ass2;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.StringTokenizer;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.DoubleWritable;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.WritableComparable;
import org.apache.hadoop.mapreduce.Counter;
import org.apache.hadoop.mapreduce.Counters;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.io.Text;;

//import ...

// This program is generated by Jiawei He
// to calculate the shortest distance and path of a directed graph.
public class SingleSourceSP {


    public static String OUT = "output";
    public static String IN = "intput";
    public static double Infinity = Double.POSITIVE_INFINITY;
    public static boolean flag= true;
    
    //Create a class to represent edges
    public static class Edge implements WritableComparable<Edge>{
    	private long fromNodeID; // starting point of an edge
    	private long toNodeID; // ending point of an edge
    	private double distance; // the distance of such edge
    	public Edge(){
    		this.fromNodeID = -1;
    		this.toNodeID = -1;
    		this.distance = 0;
    	}
    	public Edge(long fromNodeID, long toNodeID, double distance){
    		this.fromNodeID = fromNodeID;
    		this.toNodeID = toNodeID;
    		this.distance = distance;
    	}
    	public void setEdge(long fromNodeID, long toNodeID, double distance){
    		this.fromNodeID = fromNodeID;
    		this.toNodeID = toNodeID;
    		this.distance = distance;
    	}
    	public long getFromNode(){
    		return this.fromNodeID;
    	}
    	public long getToNode(){
    		return this.toNodeID;
    	}
    	public double getDistance(){
    		return this.distance;
    	}
		@Override
		public void readFields(DataInput input) throws IOException {
			// TODO Auto-generated method stub
			this.fromNodeID = input.readLong();
			this.toNodeID = input.readLong();
			this.distance = input.readDouble();
		}
		@Override
		public void write(DataOutput output) throws IOException {
			// TODO Auto-generated method stub
			output.writeLong(this.fromNodeID);
			output.writeLong(this.toNodeID);
			output.writeDouble(this.distance);
		}
		@Override
		// set the comparator in order to sort
		// based firstly on from_node
		// then secondly on to_node
		public int compareTo(Edge e) {
			// TODO Auto-generated method stub
			if(this.fromNodeID > e.fromNodeID){
				return 1;
			}else if(this.fromNodeID < e.fromNodeID){
				return -1;
			}else{
				if(this.toNodeID > e.toNodeID){
					return 1;
				}else if(this.toNodeID < e.toNodeID){
					return -1;
				}
			}
			return 0;
		}
		@Override
		// This guarantees that the key with the same from node can be
		// sent to the same reducer
		// We need to do this because the entire edge class is the key
		// in InputMapper so we have to define which hash code should be used. 
		public int hashCode(){
			int result;
			if (Long.valueOf(this.fromNodeID) != null){
				result = Long.valueOf(this.fromNodeID).hashCode();
			}
			else{
				result = 0;
			}
			return result;
		}
    	
    }
    // The first map-reduce is a single iteration to transform the
    // input text file as the require format.
    // Use Mapper to transfer input into key value pairs
    // key = (start point, end point, edge)
    // value = null
    public static class InputMapper extends Mapper<Object, Text, Edge, NullWritable>{
    	
    	public void map(Object key, Text value, Context context) throws IOException, InterruptedException {
            // YOUR JOB: map function
    		StringTokenizer itr =new StringTokenizer(value.toString(), "\n");
    		while(itr.hasMoreTokens()){
    			String[] edge = itr.nextToken().split(" ");
    			context.write(new Edge(Integer.parseInt(edge[1]), Integer.parseInt(edge[2]),Double.parseDouble(edge[3]))
    					,NullWritable.get());
    		}
        }
    }
    // For each from_node in the input key we create the following output :
    // For source node, the format is key = (source_ID, 0), value = (neighbor_list, source_ID)
    // the source_ID in value parts is the part section, since, for source, the initial path is itself so path = source_ID
    // For other nodes, the format is key = (node_ID, Infinity), value = (neighbor_list, null)
    // Currently, we have not updated the path and distance so the distance for non-source should
    // be infinity and the path to the current node is null.
    public static class InputReducer extends Reducer <Edge, NullWritable, Text, Text>{
    	private static String neighbours = ""; // static variable to record the neighbors
    	private static long lastFromNodeID = Long.MIN_VALUE;
    	
    	// For each edge 
    	public void reduce(Edge key ,Iterable<NullWritable> value, Context context) throws IOException,InterruptedException{
    		long fromNodeID = key.getFromNode();
    		// fetch the source
    		Configuration conf = context.getConfiguration();
    		long source = Long.parseLong(conf.get("source"));
    		if(fromNodeID != lastFromNodeID){// If it is a new from node
    			if(lastFromNodeID == Long.MIN_VALUE){ 
    				// if the such node is the first from_node, we create a new node info String
    				lastFromNodeID = fromNodeID; // record the node name
    				neighbours = key.getToNode()+ ":" + key.getDistance() + ",";// append neighbors
    			}else{ 
    				// If it is not the first node,
    				// we need to write the previous node info into kay value pairs
    				if(lastFromNodeID == source){ // if the current from_Node is source
    					if(neighbours.length() > 0){ 
    						// if the current neighbor list is not null
    						// add the neighbor to the list
        					String subString = neighbours.substring(0, neighbours.length()-1);
        					context.write(new Text(lastFromNodeID + "\t" + 0), new Text(subString+ "\t" + source));
        					lastFromNodeID = fromNodeID;
        					neighbours = "";
        					neighbours = key.getToNode()+ ":" + key.getDistance() + ",";
    					}
    					else if(neighbours.length() == 0){
    						// if neighbor list is empty, user string "empty" to represent the list
    						context.write(new Text(lastFromNodeID + "\t" + 0), new Text("empty"+ "\t" + source));
    					}
    				}else{// If the current node is node source
    					if(neighbours.length() > 0){ 
    						//If the current node is not source
    						// set the distance to infinity
    						// then create a neighbor list for this node
        					String subString = neighbours.substring(0, neighbours.length()-1);
        					context.write(new Text(lastFromNodeID + "\t" + Infinity), new Text(subString+ "\t" + "null"));
        					lastFromNodeID = fromNodeID;		
        					neighbours = "";
        					neighbours = key.getToNode()+ ":" + key.getDistance() + ",";
    					}
    					else if(neighbours.length() == 0){
    						// If such node has no neighbors, the list is empty
    						context.write(new Text(lastFromNodeID + "\t" + Infinity), new Text("empty" + "\t" + "null"));
    					}

    				}
    			}
    		}
    		else{
    			// If the key is not a new one, we continue appending neighbors
    			neighbours += key.getToNode()+ ":" + key.getDistance() + ",";
     		}
    	}
    	public void cleanup(Context context) throws IOException, InterruptedException{
    		// fetch the source
    		Configuration conf = context.getConfiguration();
    		long source = Long.parseLong(conf.get("source"));
    		// The last node treated by reducer should also be processed
    		// with the same mechanism.
    		if(lastFromNodeID == source && neighbours.length() > 0){ 
    			// when the current node is the source and has neighbors
				String subString = neighbours.substring(0, neighbours.length()-1);
				context.write(new Text(lastFromNodeID + "\t" + 0), new Text(subString+ "\t" + source));
			}else if (lastFromNodeID != source && neighbours.length() > 0){
				// when the current node is not the source and has neighbors
				String subString = neighbours.substring(0, neighbours.length()-1);
				context.write(new Text(lastFromNodeID + "\t" + Infinity), new Text(subString+ "\t" + "null"));
			}else if(lastFromNodeID == source && neighbours.length() == 0){
				// when the current node is the source and has  no neighbors
    			context.write(new Text(lastFromNodeID + "\t" + 0), new Text("empty"+ "\t" + source));
    		}
			else if(lastFromNodeID != source && neighbours.length() == 0){
				// when the current node is not the source and has no neighbors
    			context.write(new Text(lastFromNodeID + "\t" + Infinity), new Text("empty"+ "\t" + "null"));
    		}
    	}
    
    }
    
    // The second pair of map-reduce is an iterative program, 
    // it calculates the distance and finds the shortest path
    // it will only terminate when the terminate criterion is met
    
    // The mapper generates graph structure and distance update key value pairs
    public static class SSSPMapper extends Mapper<Object, Text, LongWritable, Text> {

        @Override
       public void map(Object key, Text value, Context context) throws IOException, InterruptedException {
            // YOUR JOB: map function
        	StringTokenizer itr = new StringTokenizer(value.toString(), "\n");
        	
        	while(itr.hasMoreTokens()){
        		// For each node received by mapper
        		// extract distance, outgoing neighbor lists and path information
        		String fromNodeInfo = itr.nextToken();
        		String[] fromNodeElement = fromNodeInfo.split("\t");
        		long fromNodeID = Long.parseLong(fromNodeElement[0].trim());
        		
        		double distance = Double.parseDouble(fromNodeElement[1].trim());
        		String neighbours = fromNodeElement[2].trim();
        		String path = fromNodeElement[3].trim();
    			// Send the graph structure using key-value pairs with the value identified by
    			// "Node#" at the very beginning.
        		if(neighbours.equals("empty")){
        			// This deals with empty neighbor list.
        			context.write(new LongWritable(fromNodeID), new Text("Node#"+ fromNodeID + "\t" + distance + "\t" + "empty" + "\t"+ path));
        			return;
        		}else{
        			// Write graph structure in a key-value pair
        			context.write(new LongWritable(fromNodeID), new Text("Node#"+ fromNodeID + "\t" + distance + "\t" + neighbours + "\t" + path));
        		}
        		if(!neighbours.equals("empty")){
        			// if neighbor list is not empty, the key-value pair
        			// (neighbor_ID, distance + the path of the from_ID) is generated
        			// the last part of path is used to record the path, not just the distence.
        			String[] neighbourList = neighbours.split(",");
            		for(String n:neighbourList){
            			String[] To_Dist = n.split(":");
            			long toNodeID = Long.parseLong(To_Dist[0]); // neighbor ID
            			double toDist = Double.parseDouble(To_Dist[1]); // distance from from_Node
            			if(distance!=Double.POSITIVE_INFINITY){
            				// If the distnace is infinity, it is unnecessary to generate such pairs.
            				context.write(new LongWritable(toNodeID), new Text("Dist#" + String.valueOf(toDist + distance) + "\t" + path));
            			}	
            		}
        		}
        	}
        
        }

    }

    // the reducer combines the results and update the distance and path accordingly
    public static class SSSPReducer extends Reducer<LongWritable, Text, LongWritable, Text> {
    	
        @Override
        public void reduce(LongWritable key, Iterable<Text> values, Context context) throws IOException, InterruptedException {
        	String nodeInfo = "";
        	double shortestDist = Double.POSITIVE_INFINITY;
        	String path_by_dist = "";
        	String path_by_node = "";
        	// YOUR JOB: reduce function
        	for(Text val : values){
        		// extract the first part to tell
        		// if it is a graph structure pair or a distance update pair
        		String[] nodeElement = val.toString().split("#");
        		String valueType = nodeElement[0];
        		if(valueType.equals("Node")){
        			// if it is a graph structure
        			// record the structure
        			nodeInfo = nodeElement[1];
        		}else{
        			// If it is a distance update node
        			// record the distance and the path given by its from_Node
        			if(shortestDist > Double.parseDouble(nodeElement[1].trim().split("\t")[0])){
        				shortestDist = Double.parseDouble(nodeElement[1].trim().split("\t")[0]);
        				path_by_dist = nodeElement[1].split("\t")[1] + "->" + key.toString();
        			}
        		}		
        	}
        	
        	String[] nodeInfoList = nodeInfo.split("\t");
        	
        	if(nodeInfo.equals("")){
        		// this means only distance update nodes are received, 
        		// indicates that the current node is a dead end
        		// just output the shortest distance and the path that is given by the from_Node
        		context.write(key, new Text(String.valueOf(shortestDist) + "\t" + "empty" +'\t'+ path_by_dist));
        		return;
        	}
        	double existingCurrentDistance = Double.parseDouble(nodeInfoList[1]);
        	path_by_node = nodeInfoList[3].trim();
        	
        	if(nodeInfoList[2].equals("empty")){
        		// If the neighbor list is "empty"
        		// this means the node is also a dead end
        		// the distance will be updated 
        		// the neighbor list will still be empty
        		if(existingCurrentDistance > shortestDist){
            		context.write(key, new Text(String.valueOf(shortestDist) + "\t" + "empty" + "\t"+path_by_dist));
            		return;
        		}else{
            		context.write(key, new Text(String.valueOf(existingCurrentDistance) + "\t" + "empty" +"\t"+ path_by_node));
            		return;
        		}

        	}
        	path_by_node = nodeInfoList[3].trim();
        	
        	String neighbourList = nodeInfoList[2];
        	// For non-dead-end nodes, 
        	// the distance, the path given by the from_node will be updated
        	// also the neighbor list will be maintained
        	if(existingCurrentDistance > shortestDist){ // if the distance needs to be updated
        		context.write(key, new Text(String.valueOf(shortestDist)+"\t"+ neighbourList + "\t" + path_by_dist));
        		// This is the counter of the map-reduce program,
        		// adding counter by one means one more update happened
        		// therefore the program should not terminate.
        		context.getCounter(TERM_COUNTER.UPDATED_EDGES).increment(1);
        	}else{// if the distance has no need to be updated
        		context.write(key, new Text(String.valueOf(existingCurrentDistance)+"\t"+ neighbourList + "\t" + path_by_node));
        	}
        	
        }
    }
    
    // The third map-reducer is a single iteration program which is used to create
    // the final output format.
    public static class findShortestPathMapper extends Mapper<Object, Text, LongWritable, Text> {
    	static boolean isDeadSource = true; // deal with the special case that the source is a dead end.
    
    	public void map(Object key, Text value, Context context) throws IOException, InterruptedException{
    		StringTokenizer itr = new StringTokenizer(value.toString(), "\n");
    		while(itr.hasMoreTokens()){
    			String[] nodeInfo = itr.nextToken().split("\t");
    			String nodeID = nodeInfo[0];
    			if((!nodeInfo[1].equals("Infinity"))&& (!nodeInfo[3].equals("null"))){
    				isDeadSource = false;// if distance is not infinity and path is not null, the source is not a dead end.
    				double distance = Double.parseDouble(nodeInfo[1]);
    				String path = nodeInfo[3];
    				// Generate key-value pairs of (nodeID, distance + \t + path)
        			context.write(new LongWritable(Long.parseLong(nodeID)), new Text(distance + "\t" + path));
    			}
    		}

    	}
    	
    	public void cleanup(Context context) throws IOException, InterruptedException{
    		//fetch the source
    		Configuration conf = context.getConfiguration();
    		long source = Long.parseLong(conf.get("source"));
    		if(isDeadSource == true){
    			// this is the special consideration of the dead end source case
    			// which is rare and extreme.
    			context.write(new LongWritable(source), new Text(0.0 + "\t" + source));
    		}
    	}
    }
    
    public static class findShortestPathReducer extends Reducer<LongWritable, Text, Text, NullWritable> {
    	public void reduce(LongWritable key, Iterable<Text> values, Context context) throws IOException, InterruptedException{
    		
    		for(Text val:values){
    			String[] elements = val.toString().split("\t");
    			// generate the output
    			// in the format of  "node_ ID \t distance to source \t path to source"
    			context.write(new Text(key.toString()+"\t" + elements[0].trim()+ "\t" + elements[1].trim()), NullWritable.get());
    		}
    		
    		
    	}
    }

    // This function is used to delete the intermediate output.
   
    public static void rmFolder(Configuration conf, String directory) throws IOException, URISyntaxException{
    	FileSystem fs = FileSystem.get(new URI("hdfs://localhost:9000"),conf);
    	Path path = new Path(directory);
    	if(fs.exists(path)){
    		fs.delete(path, true);
    	}
    }
    
    // Set up the counter
    public static enum TERM_COUNTER{
    	UPDATED_EDGES;
    }
    
    public static void main(String[] args) throws Exception {        
        IN = args[0];
        OUT = args[1];
        int iteration = 0;
        String input = IN;
        String output = OUT + iteration;

	    // YOUR JOB: Convert the input file to the desired format for iteration, i.e., 
        //           create the adjacency list and initialize the distances
        // ... ...
        Configuration conf = new Configuration();
        conf.set("source", args[2]);
        Job job = Job.getInstance(conf, "SSSP");
        job.setNumReduceTasks(1); // set the number of reducer to 1
        job.setJarByClass(SingleSourceSP.class);
        // initialize the first map-reduce
        job.setMapperClass(InputMapper.class);
        job.setReducerClass(InputReducer.class);
        
        job.setMapOutputKeyClass(Edge.class);
        job.setMapOutputValueClass(NullWritable.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(Text.class);
        
        FileInputFormat.addInputPath(job, new Path(input));
        FileOutputFormat.setOutputPath(job, new Path(output));
        
        job.waitForCompletion(true);
        
       
        boolean isdone = false;
        
        // iterate over the second map-reduce pair
        while (isdone == false) {
        	// create a counter and set the value 0
        	Counters counters = job.getCounters();
        	counters.findCounter(TERM_COUNTER.UPDATED_EDGES).setValue(0);
            // YOUR JOB: Configure and run the MapReduce job
            // ... ...                   
            // start to find the shortest distance
            // and the path
            job = Job.getInstance(conf, "Find Shortest Path");
            job.setJarByClass(SingleSourceSP.class);
            job.setMapperClass(SSSPMapper.class);
            job.setReducerClass(SSSPReducer.class);
            job.setMapOutputKeyClass(LongWritable.class);
            job.setMapOutputValueClass(Text.class);
            
            job.setOutputKeyClass(LongWritable.class);
            job.setOutputValueClass(Text.class);
            
            
            input = output;
            iteration ++;       
            output = OUT + iteration;
            
            FileInputFormat.addInputPath(job, new Path(input));
            FileOutputFormat.setOutputPath(job, new Path(output));


            //You can consider to delete the output folder in the previous iteration to save disk space.

            job.waitForCompletion(true);
            rmFolder(conf, input);
            // YOUR JOB: Check the termination criterion by utilizing the counter
            
            // get the number of counter
            // if the counter is still 0. there is no update
            // the program could terminate
            // otherwise, an update occurs
            // the next iteration should be initialized.
            counters = job.getCounters();
            Counter c = counters.findCounter(TERM_COUNTER.UPDATED_EDGES);
            if(c.getValue() == 0){ //(the termination condition is reached)
                isdone = true;
            }
        }
        
        input = output;
        iteration ++;       
        output = OUT;
        // YOUR JOB: Extract the final result using another MapReduce job with only 1 reducer, and store the results in HDFS
        
        // extract the result and output the result to 
        // the file decided by the second parameter.

        job = Job.getInstance(conf, "GatherResults");
        job.setJarByClass(SingleSourceSP.class);
        job.setMapperClass(findShortestPathMapper.class);
        job.setMapOutputKeyClass(LongWritable.class);
        job.setMapOutputValueClass(Text.class);
        job.setReducerClass(findShortestPathReducer.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputKeyClass(NullWritable.class);
        
        FileInputFormat.addInputPath(job, new Path(input));
        FileOutputFormat.setOutputPath(job, new Path(output));
        job.waitForCompletion(true);
        rmFolder(conf, input);
    }
	
}

